/**
* This file and any referenced files were automatically generated by @hyperweb/telescope@1.17.0
* DO NOT MODIFY BY HAND. Instead, download the latest proto files for your chain
* and run the transpile command or npm scripts command that is used to regenerate this bundle.
*/

import { IBinaryReader, IBinaryWriter } from "./binary";
import { Any } from "./google/protobuf/any";

import { HttpEndpoint } from "@interchainjs/types";


import { DeliverTxResponse, Event, Attribute } from "@interchainjs/types";

export { DeliverTxResponse }


export type ProtoMsg = Omit<Any, "typeUrl"> & { typeUrl: any };

export interface IAminoMsg<Amino> {
  type: any;
  value: Amino;
}

export interface IProtoType {
  $typeUrl?: any;
}

/**
 * A type generated by Telescope 1.0.
 */
export interface TelescopeGeneratedCodec<
  T = unknown,
  SDK = unknown,
  Amino = unknown
> {
  readonly typeUrl: string;
  readonly aminoType?: string;
  is?(o: unknown): o is T;
  isSDK?(o: unknown): o is SDK;
  isAmino?(o: unknown): o is Amino;
  encode: (message: T, writer?: IBinaryWriter | any) => IBinaryWriter | any;
  decode: (input: IBinaryReader | Uint8Array | any, length?: number) => T;
  fromPartial: (object: any) => T | any;
  fromJSON?: (object: any) => T | any;
  toJSON?: (message: T | any) => any;
  fromSDK?: (sdk: SDK) => T;
  fromSDKJSON?: (object: any) => SDK;
  toSDK?: (message: T) => SDK;
  fromAmino?: (amino: Amino) => T;
  toAmino?: (message: T) => Amino;
  fromAminoMsg?: (aminoMsg: IAminoMsg<Amino>) => T;
  toAminoMsg?: (message: T) => IAminoMsg<Amino>;
  toProto?: (message: T) => Uint8Array;
  fromProtoMsg?: (message: ProtoMsg) => T;
  toProtoMsg?: (message: T) => Any;
  registerTypeUrl?: () => void;
}

export type TelescopeGeneratedType<
  T = unknown,
  SDK = unknown,
  Amino = unknown
> = TelescopeGeneratedCodec<T, SDK, Amino>;

export type GeneratedType = TelescopeGeneratedCodec;

/**
 * Coin defines a token with a denomination and an amount.
 *
 * NOTE: The amount field is an Int which implements the custom method
 * signatures required by gogoproto.
 */
interface Coin {
  denom: string;
  amount: string;
}

export type EncodeObject = Message<any>;

export interface Message<T> {
  typeUrl: string;
  value: T;
}

export interface StdFee {
  amount: Coin[];
  gas: string;
  /** The granter address that is used for paying with feegrants */
  granter?: string;
  /** The fee payer address. The payer must have signed the transaction. */
  payer?: string;
}


export interface TxRpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
  signAndBroadcast?(
    signerAddress: string,
    messages: EncodeObject[],
    fee: StdFee | "auto" | number,
    memo: string
  ): Promise<DeliverTxResponse>;
}

